<!DOCTYPE html>
<html lang=zh-CN>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta property="og:description" content="喜欢清风与烈酒，也爱孤独与自由">
    <meta property="og:type" content="website">
    <meta name="description" content="喜欢清风与烈酒，也爱孤独与自由">
    <meta name="keyword"  content="3secsafe,3Sec,3Sec的博客,激自己呀！,安全，渗透测试，网络安全，信息安全">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        HTTPS访问理论基础 - 3Sec
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_28hi1hpxx24.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>

    









<meta name="generator" content="Hexo 6.3.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 从现在起，做个无欲无求的人。 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/favicon.jpeg" />
        </div>
        <div class="name">
            <i>3Sec</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/collect/">
                    <i class="iconfont icon-shoucang1"></i>
                    <span>收藏</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x1-HTTPS%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">0x1. HTTPS通信流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-1-HTTP%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">0x1.1 HTTP通信流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-2-DNS%E8%A7%A3%E6%9E%90"><span class="toc-text">0x1.2 DNS解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-2-1-%E5%9F%9F%E5%90%8D"><span class="toc-text">0x1.2.1 域名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-2-2-%E5%9F%9F%E5%90%8D%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">0x1.2.2 域名服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x1-2-3-DNS%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-text">0x1.2.3 DNS解析流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-3-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-text">0x1.3 TCP三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-4-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-text">0x1.4 TCP四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-5-HTTPS%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">0x1.5 HTTPS通信流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x1-6-TLS%E6%8F%A1%E6%89%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">0x1.6 TLS握手详解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x2-HTTP%E7%9A%84%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-text">0x2. HTTP的报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-1-HTTP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">0x2.1 HTTP报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-2-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95"><span class="toc-text">0x2.2 请求方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-3-%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-text">0x2.3 状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-4-%E5%A4%B4%E9%83%A8%E5%90%8D%E7%A7%B0"><span class="toc-text">0x2.4 头部名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x2-5-MIME%E7%B1%BB%E5%9E%8B"><span class="toc-text">0x2.5 MIME类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x3-%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">0x3. 通信中的安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-1-SYN-Flood%E6%94%BB%E5%87%BB"><span class="toc-text">0x3.1 SYN Flood攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x3-2-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84HTTP%E6%96%B9%E6%B3%95"><span class="toc-text">0x3.2 不安全的HTTP方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AE%B9%E5%BC%95%E7%94%A8%EF%BC%9A"><span class="toc-text">内容引用：</span></a></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-bg" id="search-bg"></div>
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 从现在起，做个无欲无求的人。 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        HTTPS访问理论基础
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2023-04-12 22:05:29</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#安全基础" title="安全基础">安全基础</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="0x1-HTTPS通信流程"><a href="#0x1-HTTPS通信流程" class="headerlink" title="0x1. HTTPS通信流程"></a>0x1. HTTPS通信流程</h1><h2 id="0x1-1-HTTP通信流程"><a href="#0x1-1-HTTP通信流程" class="headerlink" title="0x1.1 HTTP通信流程"></a>0x1.1 HTTP通信流程</h2><p>我们使用浏览器访问网站时，通常会经历下列几个流程：</p>
<ul>
<li>DNS解析，域名系统DNS将域名解析成IP地址，从而确认将访问哪台服务器。</li>
<li>建立TCP连接，进行TCP三次握手</li>
<li>浏览器发送请求。</li>
<li>服务器接收到请求并响应，向浏览器发送数据。</li>
<li>通信完成，关闭连接。</li>
</ul>
<h2 id="0x1-2-DNS解析"><a href="#0x1-2-DNS解析" class="headerlink" title="0x1.2 DNS解析"></a>0x1.2 DNS解析</h2><p>我们要知道，浏览器去访问网站获取资源，可不是靠我们熟知的域名获取的，比如<code>www.baidu.com</code> ，而是需要通过IP地址确认服务器从而获取资源。但是IP地址不易人们记忆，因此出现了域名，并通过域名解析协议（DNS）将域名和IP地址相互映射，将域名映射为IP地址称为正向解析，将IP地址映射为域名称为反向解析。</p>
<h3 id="0x1-2-1-域名"><a href="#0x1-2-1-域名" class="headerlink" title="0x1.2.1 域名"></a>0x1.2.1 域名</h3><p>域名有一定的层次结构，分别为根域名、顶级域名、二级域名、三级域名……</p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1460000039039278.png" alt="img"></p>
<ul>
<li>根域名：配置过域名应该知道，<code>www.baidu.com</code>会被写为<code>www.baidu.com.</code> 最后那个点就是根域名</li>
<li>顶级域名：分为通用域名和国家域名，前者如’.com’、’.net’、’.edu’等，后者如’.cn’（中国）、’.us’（美国）等</li>
<li>二级域名：通用顶级域名下的二级域名一般是指注册人使用的网上名称，国家顶级域名下的二级域名如果类似于通用顶级域名的表示注册人类别和功能的标志，如’.com.cn’则表示中国的商业行组织，以此类推。</li>
<li>三级域名：可以看作是二级域名的子域名（二级目录）</li>
</ul>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1460000039039277.png" alt="img"></p>
<h3 id="0x1-2-2-域名服务器"><a href="#0x1-2-2-域名服务器" class="headerlink" title="0x1.2.2 域名服务器"></a>0x1.2.2 域名服务器</h3><p>域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。一个域名服务器所负责管里的分层叫作*区 (ZONE)*。域名的每层都设有一个域名服务器：</p>
<ul>
<li>根域名服务器<ul>
<li>根域名服务器一共13台，保存所有顶级域名服务器的地址</li>
</ul>
</li>
<li>顶级域名服务器<ul>
<li>管理注册在该顶级域名下的所有二级域名的IP地址</li>
</ul>
</li>
<li>权限域名服务器<ul>
<li>管理一个区的域名服务器。</li>
<li>以百度为例，我们假设有 fanyi.baidu.com、ai.baidu.com、tieba.baidu.com 这三个三级域名。我们可以这样分区，fanyi.baidu.com 和 tieba.baidu.com 放在 baidu.com 权限域名服务器，ai.baidu.com 放在 ai.baidu.com 权限域名服务器中。并且 baidu.com 权限域名服务器和 ai.baidu.com 权限域名服务器是同等地位的，而具体怎么分区是百度公司根据域名多少、访问多少等情况去自己规定的。</li>
</ul>
</li>
<li>本地域名服务器<ul>
<li>本地域名服务器不在DNS层次结构中</li>
<li>当一台主机发出 DNS 查询请求时，这个查询请求报文就发送给该主机的本地域名服务器。本地域名服务器管理本地域名的解析和映射，并且能够向上级域名服务器进行查询。</li>
</ul>
</li>
</ul>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/1460000039039289.png" alt="img"></p>
<h3 id="0x1-2-3-DNS解析流程"><a href="#0x1-2-3-DNS解析流程" class="headerlink" title="0x1.2.3 DNS解析流程"></a>0x1.2.3 DNS解析流程</h3><p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20230409224218908.png" alt="image-20230409224218908"></p>
<ul>
<li><p>用户输入域名后，首先会搜索浏览器的DNS缓存，缓存中维护着一张域名和IP地址的对应表；</p>
</li>
<li><p>若没有命中，则继续从本机host文件配置（操作系统DNS缓存）中搜索</p>
</li>
<li><p>若没有命中，则继续向本地域名服务器进行递归查询。本地域名服务器会先查询本地区域资源配置，没命中则查询本地DNS解析缓存。</p>
</li>
<li><p>若没有命中，则本地DNS服务器向上级服务器进行迭代查询</p>
<ul>
<li>首先本地域名服务器向<strong>根域名服务器</strong>发起请求，根域名服务器是最高层次的，它并不会直接指明这个域名对应的 IP 地址，而是返回顶级域名服务器的地址，也就是说给本地域名服务器指明一条道路，让他去这里寻找答案；</li>
<li>本地域名服务器拿到这个<strong>顶级域名服务器</strong>的地址后，就向其发起请求，获取<strong>权限域名服务器</strong>的地址；</li>
<li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li>
</ul>
</li>
<li><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p>
</li>
<li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
</li>
<li><p>最后浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起来。</p>
</li>
</ul>
<h2 id="0x1-3-TCP三次握手"><a href="#0x1-3-TCP三次握手" class="headerlink" title="0x1.3 TCP三次握手"></a>0x1.3 TCP三次握手</h2><p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/291246111727359.png" alt="img"></p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/202304110111.png" alt="TCP 三次握手过程"></p>
<ul>
<li>客户端向服务器发送一个SYN包，并等待服务器确认。 <ul>
<li>SYN为标志位，表示请求建立连接；</li>
<li>序号为Seq&#x3D;x（x一般取随机值）</li>
<li>随后客户端进入SYN-SENT阶段</li>
</ul>
</li>
<li>服务器收到SYN包后，对该包进行确认后结束LISTEN阶段，并返回一段TCP报文<ul>
<li>标志位为SYN和ACK，表示确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并统一创建新连接；</li>
<li>序号为Seq&#x3D;y；</li>
<li>确认号为Ack&#x3D;x+1，随后服务器进入SYN-RECV阶段。</li>
</ul>
</li>
<li>客户端收到SYN+ACK包后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段，并返回最后一段报文。<ul>
<li>标志位为ACK，表示确认收到服务器端同意连接的信号；</li>
<li>序号为Seq&#x3D;x+1，表示收到服务器端的确认号ACK，并将其作为自己的序号值；</li>
<li>确认号为ACK&#x3D;y+1，表示收到服务器端序号 seq，并将其值加 1 作为自己的确认号 Ack 的值。</li>
<li>最后客户端进入ESTABLISHED。</li>
</ul>
</li>
</ul>
<p>当服务器端收到来自客户端确认收到服务器数据的报文后，得知从服务器到客户端的数据传输是正常的，从而结束 SYN-RECV 阶段，进入 ESTABLISHED 阶段，从而完成三次握手。</p>
<h2 id="0x1-4-TCP四次挥手"><a href="#0x1-4-TCP四次挥手" class="headerlink" title="0x1.4 TCP四次挥手"></a>0x1.4 TCP四次挥手</h2><p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/bye.png" alt="TCP四次挥手"></p>
<p>只要数据传完了，不管是客户端还是服务器，都可以主动发起四次挥手，释放连接。</p>
<p>以客户端发起为例：</p>
<ul>
<li>首先客户端向服务器发送一段 TCP 报文表明其想要释放 TCP 连接。<ul>
<li>标记位为 FIN，表示请求释放连接；</li>
<li>序号为 Seq &#x3D; u；</li>
<li>随后客户端进入 FIN-WAIT-1 阶段，即半关闭阶段，并且停止向服务端发送通信数据。</li>
</ul>
</li>
<li>服务器接收到客户端请求断开连接的 FIN 报文后，结束 ESTABLISHED 阶段，进入 CLOSE-WAIT 阶段并返回一段 TCP 报文<ul>
<li>标记位为 ACK，表示接收到客户端释放连接的请求；</li>
<li>序号为 Seq &#x3D; v；</li>
<li>确认号为 Ack &#x3D; u + 1，表示是在收到客户端报文的基础上，将其序号值加 1 作为本段报文确认号Ack 的值；</li>
<li>随后服务器开始准备释放服务器端到客户端方向上的连接。</li>
</ul>
</li>
</ul>
<p>客户端收到服务器发送过来的 TCP 报文后，确认服务器已经收到了客户端连接释放的请求，随后客户端结束 FIN-WAIT-1 阶段，进入 FIN-WAIT-2 阶段</p>
<ul>
<li>服务器端在发出 ACK 确认报文后，服务器端会将遗留的待传数据传送给客户端，待传输完成后即经 过 CLOSE-WAIT 阶段，便做好了释放服务器端到客户端的连接准备，再次向客户端发出一段 TCP 报文<ul>
<li>标记位为 FIN 和 ACK，表示已经准备好释放连接了</li>
<li>序号为 Seq &#x3D; w；</li>
<li>确认号 Ack &#x3D; u + 1，表示是在收到客户端报文的基础上，将其序号 Seq 的值加 1 作为本段报文确认号 Ack 的值。</li>
</ul>
</li>
</ul>
<p>随后服务器端结束 CLOSE-WAIT 阶段，进入 LAST-ACK 阶段。并且停止向客户端发送数据。</p>
<ul>
<li>客户端收到从服务器发来的 TCP 报文，确认了服务器已经做好释放连接的准备，于是结束 FIN-WAIT-2 阶段，进入 TIME-WAIT 阶段，并向服务器发送一段报文<ul>
<li>标记位为 ACK，表示接收到服务器准备好释放连接的信号；</li>
<li>序号为 Seq&#x3D; u + 1，表示是在已收到服务器报文的基础上，将其确认号 Ack 值作为本段序号的值</li>
<li>确认号为 Ack&#x3D; w + 1，表示是在收到了服务器报文的基础上，将其序号 Seq 的值作为本段报文确认号的值</li>
</ul>
</li>
</ul>
<p>随后客户端开始在 TIME-WAIT 阶段等待 2 MSL。服务器端收到从客户端发出的 TCP 报文之后结束LAST-ACK 阶段，进入 CLOSED 阶段。由此正式确认关闭服务器端到客户端方向上的连接。客户端等待完 2 MSL 之后，结束 TIME-WAIT 阶段，进入 CLOSED 阶段，由此完成「四次挥手」。</p>
<blockquote>
<p>第四次挥手是第三次挥手触发的。如果第四次挥手服务端一直没收到，那服务端会认为是不是自己的第三次挥手丢了，于是服务端不断重试发第三次挥手（FIN）.重发次数由系统的tcp_orphan_retries参数控制。重试多次还没成功，服务端直接断开链接。</p>
</blockquote>
<h2 id="0x1-5-HTTPS通信流程"><a href="#0x1-5-HTTPS通信流程" class="headerlink" title="0x1.5 HTTPS通信流程"></a>0x1.5 HTTPS通信流程</h2><p>https和http的区别在于https是建立在ssl连接层上进行通信的，在TCP三次握手之后，会再进行TLS握手，TLS握手大致流程如下：</p>
<ul>
<li>商定双方通信所使用的的 TLS 版本 (例如 TLS1.0, 1.2, 1.3等等)；</li>
<li>确定双方所要使用的密码组合；</li>
<li>客户端通过服务器的公钥和数字证书上的数字签名验证服务端的身份；</li>
<li>生成会话密钥，该密钥将用于握手结束后的对称加密。</li>
</ul>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/tls-ssl-handshake.png" alt="TLS 握手"></p>
<h2 id="0x1-6-TLS握手详解"><a href="#0x1-6-TLS握手详解" class="headerlink" title="0x1.6 TLS握手详解"></a>0x1.6 TLS握手详解</h2><p>TLS 握手中的确切步骤将根据所使用的密钥交换算法的种类和双方支持的密码套件而有所不同。RSA 密钥交换算法虽然现在被认为不安全，但曾在 1.3 之前的 TLS 版本中使用。大致如下：</p>
<ul>
<li>客户端问候（client hello） 消息：客户端通过向服务器发送“Client Hello”消息来开始握手。该消息将包含客户端支持的 TLS 版本，支持的密码套件，以及称为一串称为“客户端随机数（client random）”的随机字节。</li>
<li>服务器问候（server hello）消息： 作为对 client hello 消息的回复，服务器发送一条Server Hello，内含服务器的 SSL 证书、服务器选择的密码套件，以及“服务器随机数（server random）”，即由服务器生成的另一串随机字节。</li>
<li>身份验证：客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</li>
<li>预主密钥： 客户端再发送一串随机字节，即“预主密钥（premaster secret）”。预主密钥是使用公钥加密的，只能使用服务器的私钥解密。（客户端从服务器的 SSL 证书中获得公钥。）</li>
<li>私钥被使用：服务器对预主密钥进行解密。</li>
<li>生成会话密钥：客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。</li>
<li>客户端就绪：客户端发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li>服务器就绪：服务器发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li>实现安全对称加密：已完成握手，并使用会话密钥继续进行通信。</li>
</ul>
<p>所有 TLS 握手均使用非对称加密（公钥和私钥），但并非全都会在生成会话密钥的过程中使用私钥。例如，短暂的 Diffie-Hellman 握手过程如下：</p>
<ul>
<li>客户端问候：客户端发送客户端问候消息，内含协议版本、客户端随机数和密码套件列表。</li>
<li>服务器问候：服务器以其 SSL 证书、其选定的密码套件和服务器随机数回复。与RSA握手相比，服务器在此消息中还包括服务器的数字签名。</li>
<li>数字签名确认：客户端验证服务器的数字签名，确认服务器是它所声称的身份。</li>
<li>客户端 DH 参数：客户端将其 DH 参数发送到服务器。</li>
<li>客户端和服务器计算预主密钥：客户端和服务器使用交换的 DH 参数分别计算匹配的预主密钥，而不像 RSA 握手那样由客户端生成预主密钥并将其发送到服务器。</li>
</ul>
<p>TLS 1.3 不支持 RSA，也不支持易受攻击的其他密码套件和参数。它还缩短了 TLS 握手，使 TLS 1.3 握手更快更安全。</p>
<ul>
<li>客户端问候：客户端发送客户端问候消息，内含协议版本、客户端随机数和密码套件列表。</li>
<li>服务器生成主密钥：此时服务器已经接收到客户端随机数以及客户端的参数和密码套件。它已经拥有服务器随机数，因为它可以自己生成。因此，服务器可以创建主密钥</li>
<li>服务器问候和“完成”：服务器问候包括服务器的证书、数字签名、服务器随机数和选择的密码套件。因为它已经有了主密钥，所以它也发送了一个“完成”消息。</li>
<li>最后步骤和客户端“完成”：客户端验证签名和证书，生成主密钥，并发送“完成”消息。</li>
<li>实现安全对称加密</li>
</ul>
<h1 id="0x2-HTTP的报文结构"><a href="#0x2-HTTP的报文结构" class="headerlink" title="0x2. HTTP的报文结构"></a>0x2. HTTP的报文结构</h1><h2 id="0x2-1-HTTP报文格式"><a href="#0x2-1-HTTP报文格式" class="headerlink" title="0x2.1 HTTP报文格式"></a>0x2.1 HTTP报文格式</h2><p>HTTP的报文主要由请求行&#x2F;状态行、头部、空行、主体4部分组成：</p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20230410202903370.png" alt="image-20230410202903370"></p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/httpmsgstructure2-1024x304.png" alt="img"></p>
<h2 id="0x2-2-请求方法"><a href="#0x2-2-请求方法" class="headerlink" title="0x2.2 请求方法"></a>0x2.2 请求方法</h2><table>
<thead>
<tr>
<th>序号</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>GET</td>
<td>发送请求向服务器获取某一资源。</td>
</tr>
<tr>
<td>2</td>
<td>POST</td>
<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的创建和&#x2F;或已有资源的修改。</td>
</tr>
<tr>
<td>3</td>
<td>HEAD</td>
<td>类似于GET请求，但是响应中不包含正文，通常用于判断服务器是否响应</td>
</tr>
<tr>
<td>4</td>
<td>PUT</td>
<td>向指定资源位置上传其最新内容。</td>
</tr>
<tr>
<td>5</td>
<td>DELETE</td>
<td>请求服务器删除 Request-URI 所标识的资源。</td>
</tr>
<tr>
<td>6</td>
<td>CONNECT</td>
<td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>
</tr>
<tr>
<td>7</td>
<td>OPTIONS</td>
<td>返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。</td>
</tr>
<tr>
<td>8</td>
<td>TRACE</td>
<td>回显服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td>9</td>
<td>PATCH</td>
<td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td>
</tr>
</tbody></table>
<ul>
<li>GET</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br></pre></td></tr></table></figure>

<ul>
<li>POST</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line"></span><br><span class="line">a=1&amp;b=2</span><br></pre></td></tr></table></figure>

<ul>
<li>HEAD</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/new.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>example.com</span><br><span class="line"><span class="attribute">Content-type</span><span class="punctuation">: </span>text/html</span><br></pre></td></tr></table></figure>

<ul>
<li>PUT</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line">&lt;p&gt;New File&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>如果目标服务器当前没有并且PUT请求创建了，则返回201响应</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">201</span> Created</span><br><span class="line"><span class="attribute">Content-Location</span><span class="punctuation">: </span>/new.html</span><br></pre></td></tr></table></figure>

<p>如果目标服务器存在资源且表示已修改成功，则返回200或204响应</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Content-Location</span><span class="punctuation">: </span>/new.html</span><br></pre></td></tr></table></figure>

<ul>
<li>DELETE</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/file.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>CONNECT</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">server.example.com:80</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>server.example.com:80</span><br><span class="line"><span class="attribute">Proxy-Authorization</span><span class="punctuation">: </span>basic aGVsbG86d29ybGQ=</span><br></pre></td></tr></table></figure>

<ul>
<li>OPTIONS</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<p>响应包中会包含一个Allow首部字段，该字段的值表明了服务器支持的所有 HTTP 方法</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Allow</span><span class="punctuation">: </span>OPTIONS, GET, HEAD, POST</span><br></pre></td></tr></table></figure>

<ul>
<li>TRACE</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRACE</span> <span class="string">/index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>PATCH</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PATCH</span> <span class="string">/file.txt</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/example</span><br><span class="line"><span class="attribute">If-Match</span><span class="punctuation">: </span>&quot;e0023aa4e&quot;</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>100</span><br><span class="line"></span><br><span class="line"><span class="language-angelscript"><span class="string">[description of changes]</span></span></span><br></pre></td></tr></table></figure>

<p>响应204表示成功</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">204</span> No Content</span><br><span class="line"><span class="attribute">Content-Location</span><span class="punctuation">: </span>/file.txt</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;e0023aa4f&quot;</span><br></pre></td></tr></table></figure>



<h2 id="0x2-3-状态码"><a href="#0x2-3-状态码" class="headerlink" title="0x2.3 状态码"></a>0x2.3 状态码</h2><p>向服务器发送一个请求后，响应包中会包含一个状态码，告诉请求方这次请求的结果。状态码主要分为下列几类：</p>
<ul>
<li>1XX：信息，表示服务器收到请求，需要请求者继续执行操作；</li>
<li>2XX：成功，表示操作被成功接收并处理；</li>
<li>3XX：重定向，表示需要进一步的操作以完成请求；</li>
<li>4XX：客户端错误，表示请求包含语法错误或无法完成请求；</li>
<li>5XX：服务器错误，表示服务器在处理请求的过程中发生错误；</li>
</ul>
<p>具体如下：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue</td>
<td>继续。客户端应继续其请求</td>
</tr>
<tr>
<td>101</td>
<td>Switching Protocols</td>
<td>切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
<tr>
<td>200</td>
<td>OK</td>
<td>请求成功。</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h2 id="0x2-4-头部名称"><a href="#0x2-4-头部名称" class="headerlink" title="0x2.4 头部名称"></a>0x2.4 头部名称</h2><ul>
<li>请求头</li>
</ul>
<p>比较多，因此只选择一部分常见的活着和安全息息相关的，如有遇见在进行补充。</p>
<p>部分字段虽然放在请求头中，但是在响应头中也可能会出现。</p>
<table>
<thead>
<tr>
<th>首部字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>用来告知（服务器）客户端可以处理的内容类型，这种内容类型用MIME 类型来表示。</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>将客户端能够理解的内容编码方式通知给服务端</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>允许客户端声明它可以理解的自然语言，以及优先选择的区域方言。</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于提供服务器验证用户代理身份的凭据，允许访问受保护的资源</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>被用于在 http 请求和响应中，通过指定指令来实现缓存机制</td>
</tr>
<tr>
<td>Cookie</td>
<td>含有先前由服务器通过 Set-Cookie 标头投放或通过 JavaScript 的 Document.cookie 方法设置，然后存储到客户端的 HTTP cookie</td>
</tr>
<tr>
<td>Host</td>
<td>指明了请求将要发送到的服务器主机名和端口号</td>
</tr>
<tr>
<td>Keep-Alive</td>
<td>用消息头，允许消息发送者暗示连接的状态，还可以用来设置超时时长和最大请求数。</td>
</tr>
<tr>
<td>Origin</td>
<td>表示了请求的来源（协议、主机、端口）。例如，如果一个用户代理需要请求一个页面中包含的资源，或者执行脚本中的 HTTP 请求（fetch），那么该页面的来源（origin）就可能被包含在这次请求中。</td>
</tr>
<tr>
<td>Referer</td>
<td>包含了当前请求页面的来源页面的地址，即表示当前页面是通过此来源页面里的链接进入的。</td>
</tr>
<tr>
<td>User-Agent</td>
<td>包含了一个特征字符串，用来让网络协议的对端来识别发起请求的用户代理软件的应用类型、操作系统、软件开发商以及版本号。</td>
</tr>
</tbody></table>
<ul>
<li>响应头</li>
</ul>
<table>
<thead>
<tr>
<th>首部字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Allow</td>
<td>枚举资源所支持的 HTTP 方法的集合</td>
</tr>
<tr>
<td>Content-Type</td>
<td>指示资源的 MIME 类型，告诉客户端实际返回的内容的内容类型</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web 服务器不需要发送完整的响应。而如果内容发生了变化，使用 ETag 有助于防止资源的同时更新相互覆盖（“空中碰撞”）。</td>
</tr>
<tr>
<td>Location</td>
<td>指定的是需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义。</td>
</tr>
<tr>
<td>Server</td>
<td>包含了处理请求的源头服务器所用到的软件相关信息</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>用来由服务器端向用户代理发送 cookie，所以用户代理可在后续的请求中将其发送回服务器。服务器要发送多个 cookie，则应该在同一响应中发送多个 Set-Cookie 标头。</td>
</tr>
</tbody></table>
<h2 id="0x2-5-MIME类型"><a href="#0x2-5-MIME类型" class="headerlink" title="0x2.5 MIME类型"></a>0x2.5 MIME类型</h2><p> 媒体类型（通常称为 Multipurpose Internet Mail Extensions 或 MIME 类型）是一种标准，用来表示文档、文件或字节流的性质和格式。</p>
<p>常见的MIME类型如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>典型示例</th>
</tr>
</thead>
<tbody><tr>
<td>text</td>
<td>表明文件是普通文本</td>
<td>text&#x2F;plain、text&#x2F;html、text&#x2F;css、text&#x2F;javascript</td>
</tr>
<tr>
<td>image</td>
<td>表明是某种图像。不包括视频，但是动态图（比如动态 gif）也使用 image 类型</td>
<td>image&#x2F;gif、image&#x2F;png、image&#x2F;jpeg、 image&#x2F;bmp、image&#x2F;webp、image&#x2F;x-icon、image&#x2F;vnd.microsoft.icon</td>
</tr>
<tr>
<td>audio</td>
<td>表明是某种音频文件</td>
<td>audio&#x2F;midi、audio&#x2F;mpeg、audio&#x2F;webm、audio&#x2F;ogg、audio&#x2F;wav</td>
</tr>
<tr>
<td>video</td>
<td>表明是某种视频文件</td>
<td>video&#x2F;webm、video&#x2F;ogg</td>
</tr>
<tr>
<td>application</td>
<td>表明是某种二进制数据</td>
<td>application&#x2F;octet-stream、application&#x2F;pkcs12、application&#x2F;vnd.mspowerpoint、application&#x2F;xhtml+xml、application&#x2F;xml、application&#x2F;pdf</td>
</tr>
</tbody></table>
<h1 id="0x3-通信中的安全问题"><a href="#0x3-通信中的安全问题" class="headerlink" title="0x3. 通信中的安全问题"></a>0x3. 通信中的安全问题</h1><p>由于这篇的主要目的是介绍HTTP通信流程，因此对于安全问题只是顺带介绍下，不会全面且具体的说明，后续会专门开帖子详细讲解下。</p>
<h2 id="0x3-1-SYN-Flood攻击"><a href="#0x3-1-SYN-Flood攻击" class="headerlink" title="0x3.1 SYN Flood攻击"></a>0x3.1 SYN Flood攻击</h2><p>SYN Flood攻击是一种典型的DoS攻击，是一种利用TCP协议缺陷，发送大量伪造的TCP连接请求，从而使被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。该攻击将使服务器TCP连接资源耗尽，停止响应正常的TCP连接请求。</p>
<p>当客户端和服务器建立正常的 TCP“三次握手”时，交换看起来像这样：</p>
<ol>
<li>客户端通过向服务器发送 SYN（同步）消息来请求连接。</li>
<li>服务器通过向客户端发送回 SYN-ACK（同步确认）消息进行确认。</li>
<li>客户端以 ACK（确认）消息响应，并建立连接</li>
</ol>
<p>在 SYN 泛洪攻击中，攻击者向目标服务器上的每个端口重复发送 SYN 数据包，通常使用伪造的 IP 地址。服务器不知道受到攻击，收到多个看似合法的请求以建立通信。它使用来自每个开放端口的 SYN-ACK 数据包响应每次尝试。</p>
<p>恶意客户端要么不发送预期的 ACK，要么（如果 IP 地址被欺骗）从一开始就不会收到 SYN-ACK。无论哪种方式，受到攻击的服务器都会等待一段时间来等待对其 SYN-ACK 数据包的确认。</p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/syn-flood.jpg" alt="SYN 泛洪的进展。"></p>
<p>在此期间，服务器无法通过发送 RST 数据包关闭连接，连接保持打开状态。在连接超时之前，另一个SYN 数据包将到达。这导致越来越多的连接处于半开状态——事实上，SYN 泛洪攻击也被称为“半开”攻击。最终，当服务器的连接溢出表填满时，对合法客户端的服务将被拒绝，服务器甚至可能出现故障或崩溃。</p>
<h2 id="0x3-2-不安全的HTTP方法"><a href="#0x3-2-不安全的HTTP方法" class="headerlink" title="0x3.2 不安全的HTTP方法"></a>0x3.2 不安全的HTTP方法</h2><p>在所有的HTTP方法中，安全界认为PUT、DELETE、TRACE、PATCH是不安全的。PUT&#x2F;DELETE没有认证机制、TRACE可造成XST攻击、PATCH可修改资源的部分内容。</p>
<p>以 Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）为例：<br>Apache Tomcat部分版本中如果配置不当，将配置文件conf&#x2F;web.xml中的readonly设置为false，将导致可以使用PUT方法上传任意文件。</p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20230411225349348.png" alt="image-20230411225349348"></p>
<p><img src="/2023/04/12/HTTPS%E8%AE%BF%E9%97%AE%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/image-20230411225609933.png" alt="image-20230411225609933"></p>
<p>此CVE漏洞可利用绕过的形式上传jsp木马文件，但是此处不是本次重点，依旧后续详细介绍，此处只需直观了解不安全的HTTP方法的危害即可。</p>
<h1 id="内容引用："><a href="#内容引用：" class="headerlink" title="内容引用："></a>内容引用：</h1><ol>
<li><p>[超详细 DNS 协议解析] <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000039039275">https://segmentfault.com/a/1190000039039275</a></p>
</li>
<li><p>[认识 HTTP 报文]<a target="_blank" rel="noopener" href="http://www.yaohaixiao.com/blog/understanding-http-messages/">http://www.yaohaixiao.com/blog/understanding-http-messages/</a></p>
</li>
</ol>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>
        <div id="lv-container"></div>
        <div class="giscus"></div>
    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
 </footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>






</html>
